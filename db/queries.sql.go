// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: queries.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createCompletedTask = `-- name: CreateCompletedTask :exec
INSERT INTO taskcar.completed_task(
    task_id, queue, task_created_at, in_data, out_data, log, attempts, node_id
)
SELECT
  t.task_id, t.queue, t.created_at, t.in_data, $1::jsonb, $2, t.attempts, t.locked_by
FROM taskcar.task t
WHERE t.task_id = $3
`

type CreateCompletedTaskParams struct {
	OutData []byte
	Log     string
	TaskID  int64
}

func (q *Queries) CreateCompletedTask(ctx context.Context, arg CreateCompletedTaskParams) error {
	_, err := q.db.Exec(ctx, createCompletedTask, arg.OutData, arg.Log, arg.TaskID)
	return err
}

const createSecret = `-- name: CreateSecret :one
INSERT INTO taskcar.secret(
    name, value
) VALUES(
    $1, $2
) RETURNING secret_id
`

type CreateSecretParams struct {
	Name  string
	Value string
}

func (q *Queries) CreateSecret(ctx context.Context, arg CreateSecretParams) (int64, error) {
	row := q.db.QueryRow(ctx, createSecret, arg.Name, arg.Value)
	var secret_id int64
	err := row.Scan(&secret_id)
	return secret_id, err
}

const createTask = `-- name: CreateTask :one
INSERT INTO taskcar.task(
    queue, in_data
)
VALUES(
    $1, $2::jsonb
)
RETURNING task_id
`

type CreateTaskParams struct {
	Queue  string
	InData []byte
}

func (q *Queries) CreateTask(ctx context.Context, arg CreateTaskParams) (int64, error) {
	row := q.db.QueryRow(ctx, createTask, arg.Queue, arg.InData)
	var task_id int64
	err := row.Scan(&task_id)
	return task_id, err
}

const createTaskFailure = `-- name: CreateTaskFailure :exec
INSERT INTO taskcar.failed_task(
    task_id, queue, task_created_at, in_data, log, attempts, node_id
)
SELECT
    t.task_id, t.queue, t.created_at, t.in_data, $1, t.attempts, t.locked_by
FROM taskcar.task t
WHERE t.task_id = $2
`

type CreateTaskFailureParams struct {
	Log    string
	TaskID int64
}

func (q *Queries) CreateTaskFailure(ctx context.Context, arg CreateTaskFailureParams) error {
	_, err := q.db.Exec(ctx, createTaskFailure, arg.Log, arg.TaskID)
	return err
}

const deleteTask = `-- name: DeleteTask :exec
DELETE FROM taskcar.task
WHERE task_id = $1
`

func (q *Queries) DeleteTask(ctx context.Context, taskID int64) error {
	_, err := q.db.Exec(ctx, deleteTask, taskID)
	return err
}

const dequeTasks = `-- name: DequeTasks :many
UPDATE taskcar.task
SET locked_by = $1, attempts = attempts + 1
WHERE task.task_id = (
    SELECT
        t.task_id
    FROM taskcar.task t

    WHERE t.queue = $2
       AND t.task_id NOT IN (SELECT task_id from taskcar.task_backedoff)
       AND t.locked_by IS NULL
    ORDER BY created_at asc
    LIMIT $3::int
    FOR UPDATE SKIP LOCKED
)
RETURNING task_id, queue, created_at, in_data
`

type DequeTasksParams struct {
	NodeID *int64
	Queue  string
	Limit  int32
}

type DequeTasksRow struct {
	TaskID    int64
	Queue     string
	CreatedAt pgtype.Timestamptz
	InData    []byte
}

func (q *Queries) DequeTasks(ctx context.Context, arg DequeTasksParams) ([]DequeTasksRow, error) {
	rows, err := q.db.Query(ctx, dequeTasks, arg.NodeID, arg.Queue, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DequeTasksRow
	for rows.Next() {
		var i DequeTasksRow
		if err := rows.Scan(
			&i.TaskID,
			&i.Queue,
			&i.CreatedAt,
			&i.InData,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSecrets = `-- name: GetSecrets :many
SELECT
    name, value
FROM taskcar.secret
WHERE
    name = ANY($1::text[])
`

type GetSecretsRow struct {
	Name  string
	Value string
}

func (q *Queries) GetSecrets(ctx context.Context, names []string) ([]GetSecretsRow, error) {
	rows, err := q.db.Query(ctx, getSecrets, names)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSecretsRow
	for rows.Next() {
		var i GetSecretsRow
		if err := rows.Scan(&i.Name, &i.Value); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const nodeHeartbeat = `-- name: NodeHeartbeat :exec
UPDATE taskcar.node
SET heartbeat_at = now()
WHERE node_id = $1
`

func (q *Queries) NodeHeartbeat(ctx context.Context, nodeID int64) error {
	_, err := q.db.Exec(ctx, nodeHeartbeat, nodeID)
	return err
}

const nodeShutdown = `-- name: NodeShutdown :exec
UPDATE taskcar.node
SET up = false
WHERE node_id = $1
`

func (q *Queries) NodeShutdown(ctx context.Context, nodeID int64) error {
	_, err := q.db.Exec(ctx, nodeShutdown, nodeID)
	return err
}

const notifyChannel = `-- name: NotifyChannel :exec
SELECT pg_notify(
    $1,
    ''
)
`

func (q *Queries) NotifyChannel(ctx context.Context, channel string) error {
	_, err := q.db.Exec(ctx, notifyChannel, channel)
	return err
}

const releaseTask = `-- name: ReleaseTask :exec
UPDATE taskcar.task
SET locked_by = null
WHERE task_id = $1
  AND locked_by = $2
`

type ReleaseTaskParams struct {
	TaskID int64
	NodeID *int64
}

func (q *Queries) ReleaseTask(ctx context.Context, arg ReleaseTaskParams) error {
	_, err := q.db.Exec(ctx, releaseTask, arg.TaskID, arg.NodeID)
	return err
}

const taskSetBackoff = `-- name: TaskSetBackoff :exec
INSERT INTO taskcar.task_backoff(
queue, backoff_path, backoff_key, until
) SELECT
    q.queue, q.backoff_path, t.in_data #> q.backoff_path, now() + q.backoff_int
FROM taskcar.task t
JOIN taskcar.queue q ON t.queue = q.queue
WHERE t.task_id = $1
`

func (q *Queries) TaskSetBackoff(ctx context.Context, taskID int64) error {
	_, err := q.db.Exec(ctx, taskSetBackoff, taskID)
	return err
}

const upsertNode = `-- name: UpsertNode :one
INSERT INTO taskcar.node(
    hostname, ip_address, up
) VALUES(
    $1, $2, true
)
ON CONFLICT (hostname) DO UPDATE
SET
    heartbeat_at = now(),
    ip_address = $2
RETURNING node_id, created_at, hostname, ip_address, heartbeat_at
`

type UpsertNodeParams struct {
	Hostname string
	Ip       string
}

type UpsertNodeRow struct {
	NodeID      int64
	CreatedAt   pgtype.Timestamptz
	Hostname    string
	IpAddress   string
	HeartbeatAt pgtype.Timestamptz
}

func (q *Queries) UpsertNode(ctx context.Context, arg UpsertNodeParams) (UpsertNodeRow, error) {
	row := q.db.QueryRow(ctx, upsertNode, arg.Hostname, arg.Ip)
	var i UpsertNodeRow
	err := row.Scan(
		&i.NodeID,
		&i.CreatedAt,
		&i.Hostname,
		&i.IpAddress,
		&i.HeartbeatAt,
	)
	return i, err
}

const upsertQueue = `-- name: UpsertQueue :exec
INSERT INTO taskcar.queue(
    queue, max_attempts, backoff_path, backoff_int
) VALUES(
    $1,
    $2,
    $3,
    $4
) on CONFLICT (queue) DO UPDATE
SET
    max_attempts = $2,
    backoff_path = $3,
    backoff_int = $4
`

type UpsertQueueParams struct {
	Queue       string
	MaxAttempts int32
	BackoffPath []string
	BackoffInt  pgtype.Interval
}

func (q *Queries) UpsertQueue(ctx context.Context, arg UpsertQueueParams) error {
	_, err := q.db.Exec(ctx, upsertQueue,
		arg.Queue,
		arg.MaxAttempts,
		arg.BackoffPath,
		arg.BackoffInt,
	)
	return err
}
